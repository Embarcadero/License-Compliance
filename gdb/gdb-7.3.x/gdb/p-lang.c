/* Pascal language support routines for GDB, the GNU debugger.

   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This file is derived from c-lang.c */

#include "defs.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcore.h"
#include "expression.h"
#include "exceptions.h"
#include "parser-defs.h"
#include "language.h"
#include "p-lang.h"
#include "c-lang.h" /* for c_string_type, c_classify_type  */
#include "valprint.h"
#include "value.h"
#include "charset.h"
#include "gdb_obstack.h"
#include <ctype.h>

extern void _initialize_pascal_language (void);


/* All GPC versions until now (2007-09-27) also define a symbol called
   '_p_initialize'.  Check for the presence of this symbol first.  */
static const char GPC_P_INITIALIZE[] = "_p_initialize";

/* The name of the symbol that GPC uses as the name of the main
   procedure (since version 20050212).  */
static const char GPC_MAIN_PROGRAM_NAME_1[] = "_p__M0_main_program";

/* Older versions of GPC (versions older than 20050212) were using
   a different name for the main procedure.  */
static const char GPC_MAIN_PROGRAM_NAME_2[] = "pascal_main_program";

/* EMBARCADERO LOCAL Delphi strings */
static struct type *builtin_type_Delphi_char;


/* Function returning the special symbol name used
   by GPC for the main procedure in the main program
   if it is found in minimal symbol list.
   This function tries to find minimal symbols generated by GPC
   so that it finds the even if the program was compiled
   without debugging information.
   According to information supplied by Waldeck Hebisch,
   this should work for all versions posterior to June 2000.  */

const char *
pascal_main_name (void)
{
  struct minimal_symbol *msym;

  msym = lookup_minimal_symbol (GPC_P_INITIALIZE, NULL, NULL);

  /*  If '_p_initialize' was not found, the main program is likely not
     written in Pascal.  */
  if (msym == NULL)
    return NULL;

  msym = lookup_minimal_symbol (GPC_MAIN_PROGRAM_NAME_1, NULL, NULL);
  if (msym != NULL)
    {
      return GPC_MAIN_PROGRAM_NAME_1;
    }

  msym = lookup_minimal_symbol (GPC_MAIN_PROGRAM_NAME_2, NULL, NULL);
  if (msym != NULL)
    {
      return GPC_MAIN_PROGRAM_NAME_2;
    }

  /*  No known entry procedure found, the main program is probably
      not compiled with GPC.  */
  return NULL;
}

/* Determines if type TYPE is a pascal string type.
   Returns a positive value if the type is a known pascal string type.
   This function is used by p-valprint.c code to allow better string display.
   If it is a pascal string type, then it also sets info needed
   to get the length and the data of the string
   length_pos, length_size and string_pos are given in bytes.
   char_size gives the element size in bytes.
   FIXME: if the position or the size of these fields
   are not multiple of TARGET_CHAR_BIT then the results are wrong
   but this does not happen for Free Pascal nor for GPC.  */
int
is_pascal_string_type (struct type *type,int *length_pos,
                       int *length_size, int *string_pos,
		       struct type **char_type,
		       char **arrayname)
{
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_STRUCT)
    {
      /* Old Borland type pascal strings from Free Pascal Compiler.  */
      /* Two fields: length and st.  */
      if (TYPE_NFIELDS (type) == 2
	  && TYPE_FIELD_NAME (type, 0)
	  && strcmp (TYPE_FIELD_NAME (type, 0), "length") == 0
	  && TYPE_FIELD_NAME (type, 1)
	  && strcmp (TYPE_FIELD_NAME (type, 1), "st") == 0)
        {
          if (length_pos)
	    *length_pos = TYPE_FIELD_BITPOS (type, 0) / TARGET_CHAR_BIT;
          if (length_size)
	    *length_size = TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0));
          if (string_pos)
	    *string_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;
          if (char_type)
	    *char_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 1));
 	  if (arrayname)
	    *arrayname = TYPE_FIELD_NAME (type, 1);
         return 2;
        };
      /* GNU pascal strings.  */
      /* Three fields: Capacity, length and schema$ or _p_schema.  */
      if (TYPE_NFIELDS (type) == 3
	  && TYPE_FIELD_NAME (type, 0)
	  && strcmp (TYPE_FIELD_NAME (type, 0), "Capacity") == 0
	  && TYPE_FIELD_NAME (type, 1)
	  && strcmp (TYPE_FIELD_NAME (type, 1), "length") == 0)
        {
	  if (length_pos)
	    *length_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;
	  if (length_size)
	    *length_size = TYPE_LENGTH (TYPE_FIELD_TYPE (type, 1));
	  if (string_pos)
	    *string_pos = TYPE_FIELD_BITPOS (type, 2) / TARGET_CHAR_BIT;
          /* FIXME: how can I detect wide chars in GPC ??  */
          if (char_type)
	    {
	      *char_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 2));

	      if (TYPE_CODE (*char_type) == TYPE_CODE_ARRAY)
		*char_type = TYPE_TARGET_TYPE (*char_type);
	    }
 	  if (arrayname)
	    *arrayname = TYPE_FIELD_NAME (type, 2);
         return 3;
        };
    }
  return 0;
}

/* EMBARCADERO LOCAL: begin Delphi UTF support */
static void pascal_one_char (int, struct type *, struct ui_file *, int *);

/* Print a wide character W to OUTPUT.  ORIG is a pointer to the
   original (target) bytes representing the character, ORIG_LEN is the
   number of valid bytes.  WIDTH is the number of bytes in a base
   characters of the type.  OUTPUT is an obstack to which wide
   characters are emitted.  IN_QUOTES is reset to 0 if a char is
   written with #4 notation.  NEED_ESCAPE is an in/out flag which is
   used to track numeric escapes across calls.  */

static void
pascal_print_wchar (gdb_wint_t w, const gdb_byte *orig,
		    int orig_len, int width,
		    enum bfd_endian byte_order,
		    struct obstack *output, int *in_quotes)
{
  if (gdb_iswprint (w))
    {
      gdb_wchar_t wchar = w;

      if (!(*in_quotes))
	obstack_grow_wstr (output, LCST ("'"));
      *in_quotes = 1;

      /* ' becomes ''.  */
      if (w == LCST ('\''))
	obstack_grow_wstr (output, LCST ("''"));
      obstack_grow (output, &wchar, sizeof (gdb_wchar_t));
    }
  else
    {
      int i;

      /* End the string in preparation for #4 notation.  */
      if (*in_quotes)
	obstack_grow_wstr (output, LCST ("'"));
      *in_quotes = 0;

      for (i = 0; i + width <= orig_len; i += width)
	{
	  char octal[30];
	  ULONGEST value = extract_unsigned_integer (&orig[i], width,
						     byte_order);
	  /* If the value fits in 3 octal digits, print it that
	      way.  Otherwise, print it as a hex escape.  */
	  if (value <= 0777)
	    sprintf (octal, "#%.3o", (int) (value & 0777));
	  else
	    sprintf (octal, "#$%lx", (long) value);
	  append_string_as_wide (octal, output);
	}
      /* If we somehow have extra bytes, print them now.  */
      while (i < orig_len)
	{
	  char octal[5];
	  sprintf (octal, "#%.3o", orig[i] & 0xff);
	  append_string_as_wide (octal, output);
	  ++i;
	}
    }
}
/* EMBARCADERO LOCAL: end Delphi UTF support */

/* Print the character C on STREAM as part of the contents of a literal
   string.
   In_quotes is reset to 0 if a char is written with #4 notation.  */

static void
pascal_one_char (int c, struct type *type, struct ui_file *stream,
		 int *in_quotes)
{
  /* EMBARCADERO LOCAL: begin Delphi UTF support */
  enum bfd_endian byte_order
    = gdbarch_byte_order (get_type_arch (type));
  struct obstack wchar_buf, output;
  struct cleanup *cleanups;
  const char *encoding;
  gdb_byte *buf;
  struct wchar_iterator *iter;
  /* EMBARCADERO LOCAL: Delphi UTF support */
  size_t nbytes_in_char;

  c_classify_type (type, get_type_arch (type), &encoding);

#if 0
  buf = alloca (TYPE_LENGTH (type));
  pack_long (buf, type, c);
#else
  /* EMBARCADERO LOCAL FIXME: It can take multiple UTF chars to complete a
     Unicode char (which can be up to 4 bytes) - we need to account for the
     entire char.  */
  /* EMBARCADERO LOCAL FIXME: Assumes byte order matches host.  */
  nbytes_in_char = get_nbytes_in_wchar (encoding, &c);
  if (nbytes_in_char)
    {
      /* EMBARCADERO LOCAL FIXME: Assumes byte order matches host.  */
      buf = alloca (nbytes_in_char);
      memcpy (&buf[0], &c, nbytes_in_char);
    }
  else
    {
      nbytes_in_char = TYPE_LENGTH (type);
      buf = alloca (nbytes_in_char);
      pack_long (buf, type, c);
    }
#endif

  /* EMBARCADERO LOCAL: Delphi UTF support */
  iter = make_wchar_iterator (buf, nbytes_in_char, encoding,
			      TYPE_LENGTH (type));
  cleanups = make_cleanup_wchar_iterator (iter);

  /* This holds the printable form of the wchar_t data.  */
  obstack_init (&wchar_buf);
  make_cleanup_obstack_free (&wchar_buf);

  while (1)
    {
      int num_chars;
      gdb_wchar_t *chars;
      const gdb_byte *buf;
      size_t buflen;
      int is_printable = 0;
      enum wchar_iterate_result result;

      num_chars = wchar_iterate (iter, &result, &chars, &buf, &buflen);
      if (num_chars < 0)
	break;
      if (num_chars > 0)
	{
	  /* If all characters are printable, print them.  Otherwise,
	     we're going to have to print using #4 notation.  We
	     check all characters because we don't know the character
	     boundaries.  */
	  int i;

	  is_printable = 1;
	  for (i = 0; i < num_chars; ++i)
	    if (!gdb_iswprint (chars[i]))
	      {
		is_printable = 0;
		break;
	      }

	  if (is_printable)
	    {
	      for (i = 0; i < num_chars; ++i)
		pascal_print_wchar (chars[i], buf, buflen, TYPE_LENGTH (type),
				    byte_order, &wchar_buf, in_quotes);
	    }
	}

      /* This handles the NUM_CHARS == 0 case as well.  */
      if (!is_printable)
	pascal_print_wchar (gdb_WEOF, buf, buflen, TYPE_LENGTH (type),
			    byte_order, &wchar_buf, in_quotes);
    }
  if (*in_quotes)
    {
      obstack_grow_wstr (&wchar_buf, LCST ("'"));
      *in_quotes = 0;
    }

  /* The output in the host encoding.  */
  obstack_init (&output);
  make_cleanup_obstack_free (&output);

  convert_between_encodings (INTERMEDIATE_ENCODING, host_charset (),
			     obstack_base (&wchar_buf),
			     obstack_object_size (&wchar_buf),
			     1, &output, translit_char);
  obstack_1grow (&output, '\0');

  fputs_filtered (obstack_base (&output), stream);

  do_cleanups (cleanups);
  /* EMBARCADERO LOCAL: end Delphi UTF support */
}

static void pascal_emit_char (int c, struct type *type,
			      struct ui_file *stream, int quoter);

/* Print the character C on STREAM as part of the contents of a literal
   string whose delimiter is QUOTER.  Note that that format for printing
   characters and strings is language specific.  */

static void
pascal_emit_char (int c, struct type *type, struct ui_file *stream, int quoter)
{
  int in_quotes = 0;

  /* EMBARCADERO LOCAL: Delphi UTF support */
  pascal_one_char (c, type, stream, &in_quotes);
}

void
pascal_printchar (int c, struct type *type, struct ui_file *stream)
{
  int in_quotes = 0;

  /* EMBARCADERO LOCAL: Delphi UTF support */
  pascal_one_char (c, type, stream, &in_quotes);
}

/* Print the character string STRING, printing at most LENGTH characters.
   Printing stops early if the number hits print_max; repeat counts
   are printed as appropriate.  Print ellipses at the end if we
   had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.  */

void
pascal_printstr (struct ui_file *stream, struct type *type,
		 const gdb_byte *string, unsigned int length,
		 const char *user_encoding, int force_ellipses,
		 const struct value_print_options *options)
{
  enum bfd_endian byte_order = gdbarch_byte_order (get_type_arch (type));
  unsigned int i;
  unsigned int things_printed = 0;
  int in_quotes = 0;
  int need_comma = 0;
  /* EMBARCADERO LOCAL: begin Delphi UTF support */
  int width = TYPE_LENGTH (type);
  struct obstack wchar_buf, output;
  struct cleanup *cleanup;
  enum c_string_type str_type;
  const char *type_encoding;
  const char *encoding;
  struct wchar_iterator *iter;
  int finished = 0;

  /* If the string was not truncated due to `set print elements', and
     the last byte of it is a null, we don't print that, in traditional C
     style.  */
  if (!force_ellipses
      && length > 0
      && (extract_unsigned_integer (string + (length - 1) * width,
				    width, byte_order) == 0))
    length--;

  str_type = (c_classify_type (type, get_type_arch (type), &type_encoding)
	      & ~C_CHAR);
  encoding = (user_encoding && *user_encoding)
    ? user_encoding : type_encoding;

  if (length == 0)
    {
      fputs_filtered ("''", stream);
      return;
    }

  if (length == -1)
    {
      unsigned long current_char = 1;
      for (i = 0; current_char; ++i)
	{
	  QUIT;
	  current_char = extract_unsigned_integer (string + i * width,
						   width, byte_order);
	}
      length = i;
    }

  /* Arrange to iterate over the characters, in wchar_t form.  */
  iter = make_wchar_iterator (string, length * width, encoding, width);
  cleanup = make_cleanup_wchar_iterator (iter);

  /* WCHAR_BUF is the obstack we use to represent the string in
     wchar_t form.  */
  obstack_init (&wchar_buf);
  make_cleanup_obstack_free (&wchar_buf);

  while (!finished && things_printed < options->print_max)
    {
      int num_chars;
      enum wchar_iterate_result result;
      gdb_wchar_t *chars;
      const gdb_byte *buf;
      size_t buflen;

      QUIT;

      if (need_comma)
	{
	  obstack_grow_wstr (&wchar_buf, LCST (", "));
	  need_comma = 0;
	}

      num_chars = wchar_iterate (iter, &result, &chars, &buf, &buflen);
      /* We only look at repetitions when we were able to convert a
	 single character in isolation.  This makes the code simpler
	 and probably does the sensible thing in the majority of
	 cases.  */
      while (num_chars == 1 && things_printed < options->print_max)
	{
	  /* Count the number of repetitions.  */
	  unsigned int reps = 0;
	  gdb_wchar_t current_char = chars[0];
	  const gdb_byte *orig_buf = buf;
	  int orig_len = buflen;

	  if (need_comma)
	    {
	      obstack_grow_wstr (&wchar_buf, LCST (", "));
	      need_comma = 0;
	    }

	  while (num_chars == 1 && current_char == chars[0])
	    {
	      num_chars = wchar_iterate (iter, &result, &chars, &buf, &buflen);
	      ++reps;
	    }

	  /* Emit CURRENT_CHAR according to the repetition count and
	     options.  */
	  if (reps > options->repeat_count_threshold)
	    {
	      /* End the previous string.  */
	      if (in_quotes)
		{
		  obstack_grow_wstr (&wchar_buf, LCST ("', "));
		  in_quotes = 0;
		}
	      /* Print the repeated character.  */
	      pascal_print_wchar (current_char, orig_buf, orig_len, width,
				  byte_order, &wchar_buf, &in_quotes);
	      if (in_quotes)
		{
		  obstack_grow_wstr (&wchar_buf, LCST ("'"));
		  in_quotes = 0;
		}
	      {
		/* Painful gyrations.  */
		int j;
		char *s = xstrprintf (_(" <repeats %u times>"), reps);
		for (j = 0; s[j]; ++j)
		  {
		    gdb_wchar_t w = gdb_btowc (s[j]);
		    obstack_grow (&wchar_buf, &w, sizeof (gdb_wchar_t));
		  }
		xfree (s);
	      }
	      things_printed += options->repeat_count_threshold;
	      need_comma = 1;
	    }
	  else
	    {
	      /* Saw the character one or more times, but fewer than
		 the repetition threshold.  */
	      while (reps-- > 0)
		{
		  pascal_print_wchar (current_char, orig_buf, orig_len, width,
				      byte_order, &wchar_buf, &in_quotes);
		  ++things_printed;
		}
	    }
	}

      /* NUM_CHARS and the other outputs from wchar_iterate are valid
	 here regardless of which branch was taken above.  */
      if (num_chars < 0)
	{
	  /* Hit EOF.  */
	  finished = 1;
	  break;
	}

      switch (result)
	{
	case wchar_iterate_invalid:
	  pascal_print_wchar (gdb_WEOF, buf, buflen, width,
			      byte_order, &wchar_buf, &in_quotes);
	  break;

	case wchar_iterate_incomplete:
	  /* End the previous string.  */
	  if (in_quotes)
	    {
	      obstack_grow_wstr (&wchar_buf, LCST ("',"));
	      in_quotes = 0;
	    }
	  obstack_grow_wstr (&wchar_buf, LCST (" <incomplete sequence "));
	  pascal_print_wchar (gdb_WEOF, buf, buflen, width,
			      byte_order, &wchar_buf, &in_quotes);
	  if (in_quotes)
	    {
	      obstack_grow_wstr (&wchar_buf, LCST ("'"));
	      in_quotes = 0;
	    }
	  obstack_grow_wstr (&wchar_buf, LCST (">"));
	  finished = 1;
	  break;
	}
    }

  /* Terminate the quotes if necessary.  */
  if (in_quotes)
    obstack_grow_wstr (&wchar_buf, LCST ("'"));

  if (force_ellipses || !finished)
    obstack_grow_wstr (&wchar_buf, LCST ("..."));

  /* OUTPUT is where we collect `char's for printing.  */
  obstack_init (&output);
  make_cleanup_obstack_free (&output);

  convert_between_encodings (INTERMEDIATE_ENCODING, host_charset (),
			     obstack_base (&wchar_buf),
			     obstack_object_size (&wchar_buf),
			     1, &output, translit_char);
  obstack_1grow (&output, '\0');

  fputs_filtered (obstack_base (&output), stream);

  do_cleanups (cleanup);
  /* EMBARCADERO LOCAL: end Delphi UTF support */
}

/* EMBARCADERO LOCAL begin Delphi types */
/* Obtain a Delphi string from the inferior storing it in a newly allocated
   buffer in BUFFER, which should be freed by the caller.  If the in-
   and out-parameter *LENGTH is specified at -1, the string is read
   until a null character of the appropriate width is found, otherwise
   the string is read to the length of characters specified.  The size
   of a character is determined by the length of the target type of
   the pointer or array.  If VALUE is an array with a known length,
   the function will not read past the end of the array.  On
   completion, *LENGTH will be set to the size of the string read in
   characters.  (If a length of -1 is specified, the length returned
   will not include the null character).  CHARSET is always set to the
   target charset.  */

void
pascal_get_string (struct value *value, gdb_byte **buffer,
	      int *length, struct type **char_type,
	      const char **charset)
{
  int err, width;
  unsigned int fetchlimit;
  struct type *type = check_typedef (value_type (value));
  struct type *element_type = 0;
  int req_length = *length;
  enum bfd_endian byte_order
    = gdbarch_byte_order (get_type_arch (type));
  enum c_string_type kind;
  CORE_ADDR addr = 0;
  /* EMBARCADERO LOCAL begin get print_max limit */
  struct value_print_options opts;
  get_user_print_options (&opts);
  /* EMBARCADERO LOCAL end get print_max limit */

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      element_type = TYPE_TARGET_TYPE (type);
      /* If we know the size of the array, we can use it as a limit on
	 the number of characters to be fetched.  */
      if (TYPE_NFIELDS (type) == 1
	  && TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_RANGE)
	{
	  LONGEST low_bound, high_bound;

	  get_discrete_bounds (TYPE_FIELD_TYPE (type, 0),
			       &low_bound, &high_bound);
	  fetchlimit = high_bound - low_bound + 1;
	}
      else
	fetchlimit = UINT_MAX;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRING)
    {
      CORE_ADDR valaddr;
      unsigned int stringcharwidth = 0;
      unsigned int stringlength = 0;

      /* We need to read the string's length from memory,
	  at 4 bytes before the start of the string.  */
      /* This better be an lvalue.  */
      if (VALUE_LVAL (value) != lval_memory)
	error (_("Attempt to take valaddr of value not located in memory."));
      valaddr = value_address(value);

      /* Dereference the valaddr to get the start of the string.  */
      read_memory (valaddr, (gdb_byte*)&addr, 4);
      if (addr == 0)
	error (_("Can't dereference uninitialized string"));

      /* The string length is 4 bytes before the string.  */
      read_memory (addr - 4, (gdb_byte*)&stringlength, 4);

      /* EMBARCADERO LOCAL begin limit string length to print_max size */
      stringlength = min (opts.print_max + 1, stringlength);
      /* EMBARCADERO LOCAL end limit string length to print_max size */

      /* The char size is 10 bytes before the string.  */
      read_memory (addr - 10, (gdb_byte*)&stringcharwidth, 2);
      element_type = language_string_char_type (current_language,
						get_type_arch (type));
      /* EMBARCADERO LOCAL stringcharwidth <= 2(pascal_char_type) set it to
      actual size. RawByteString has (char) width not (unsigned short) */
      if (stringcharwidth != TYPE_LENGTH (element_type) && stringcharwidth <= 2)
        element_type->length = stringcharwidth;
      else if (stringcharwidth != TYPE_LENGTH (element_type))  
        error (_("Unknown character type for string"));
      fetchlimit = stringlength + 1;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      element_type = TYPE_TARGET_TYPE (type);
      fetchlimit = UINT_MAX;
    }
  else
    /* We work only with arrays, strings and pointers.  */
    goto error;

  if (element_type == NULL)
    goto error;
  if (! c_textual_element_type (element_type, 0))
    goto error;
  kind = c_classify_type (element_type,
			  get_type_arch (element_type),
			  charset);
  width = TYPE_LENGTH (element_type);

  /* If the string lives in GDB's memory instead of the inferior's,
     then we just need to copy it to BUFFER.  Also, since such strings
     are arrays with known size, FETCHLIMIT will hold the size of the
     array.  */
  if ((VALUE_LVAL (value) == not_lval
       || VALUE_LVAL (value) == lval_internalvar)
      && fetchlimit != UINT_MAX)
    {
      int i;
      const gdb_byte *contents = value_contents (value);

      /* If a length is specified, use that.  */
      if (*length >= 0)
	i  = *length;
      else
 	/* Otherwise, look for a null character.  */
 	for (i = 0; i < fetchlimit; i++)
	  if (extract_unsigned_integer (contents + i * width,
					width, byte_order) == 0)
 	    break;
  
      /* I is now either a user-defined length, the number of non-null
 	 characters, or FETCHLIMIT.  */
      gdb_assert( i < opts.print_max + 1);
      *length = i * width;
      *buffer = xmalloc (*length);
      memcpy (*buffer, contents, *length);
      err = 0;
    }
  else
    {
      /* If we had a string type, addr will have been set above.  */
      if (!addr)
	addr = value_as_address (value);

      err = read_string (addr, *length, width, fetchlimit,
			 byte_order, buffer, length);
      if (err)
	{
	  xfree (*buffer);
	  if (err == EIO)
	    throw_error (MEMORY_ERROR, "Address %s out of bounds",
			 paddress (get_type_arch (type), addr));
	  else
	    error (_("Error reading string from inferior: %s"),
		   safe_strerror (err));
	}
    }

  /* If the LENGTH is specified at -1, we want to return the string
     length up to the terminating null character.  If an actual length
     was specified, we want to return the length of exactly what was
     read.  */
  if (req_length == -1)
    /* If the last character is null, subtract it from LENGTH.  */
    if (*length > 0
 	&& extract_unsigned_integer (*buffer + *length - width,
				     width, byte_order) == 0)
      *length -= width;
  
  /* The read_string function will return the number of bytes read.
     If length returned from read_string was > 0, return the number of
     characters read by dividing the number of bytes by width.  */
  if (*length != 0)
     *length = *length / width;

  *char_type = element_type;

  return;

 error:
  {
    char *type_str;

    type_str = type_to_string (type);
    if (type_str)
      {
	make_cleanup (xfree, type_str);
	error (_("Trying to read string with inappropriate type `%s'."),
	       type_str);
      }
    else
      error (_("Trying to read string with inappropriate type."));
  }
}

int
pascal_string_lower_bound (struct gdbarch *gdbarch)
{
#if 0 /* FIXME: how to test for Android?  */
  /* Default for Pascal is 1.  */
  int lowbound = 1;

  /* Note: the lower bound is 0 for Dcc "nextgen" compilers.  */
  if (gdbarch
      && (gdbarch_osabi (gdbarch) == GDB_OSABI_DARWINV7
	  || gdbarch_osabi (gdbarch) == GDB_OSABI_DARWINV7F
	  || gdbarch_osabi (gdbarch) == GDB_OSABI_DARWINV7S
	  || gdbarch_osabi (gdbarch) == GDB_OSABI_DARWINV7K))
    lowbound = 0;
  return lowbound;
#else
  if (gdbarch_osabi(gdbarch) == GDB_OSABI_LINUX && !is_target_linux_android())
    return 1;
  else
    return 0;
#endif
}

struct type *
pascal_char_type (struct gdbarch *gdbarch)
{
  if (!builtin_type_Delphi_char)
    builtin_type_Delphi_char
      = arch_character_type (gdbarch, 16, 1, "N6System8WideCharE");
  return builtin_type_Delphi_char;
}

struct type *
pascal_create_string_type (struct gdbarch *gdbarch)
{
  int lowbound;
  struct type *rangetype;
  struct type *stringtype;

  lowbound = pascal_string_lower_bound (gdbarch);
  /* Length is unknown until we read the data, so make it 1 for now.  */
  rangetype = create_range_type ((struct type *) NULL,
				  builtin_type (gdbarch)->builtin_int,
				  lowbound, lowbound + 1);
  stringtype = create_array_type ((struct type *) NULL,
				  pascal_char_type (gdbarch),
				  rangetype);

  /* EMBARCADERO LOCAL Delphi string type */
  /* On 32-bit platforms, a string variable occupies 4 bytes of memory
     (and 8 bytes on 64-bit) that contain a pointer
     to a dynamically allocated string.  */
  TYPE_LENGTH (stringtype)
    = TYPE_LENGTH (builtin_type(gdbarch)->builtin_data_ptr);

  TYPE_NAME (stringtype) = "string";
  TYPE_CODE (stringtype) = TYPE_CODE_STRING;
  return stringtype;
}


/* Table mapping opcodes into strings for printing operators
   and precedences of the operators.  */

const struct op_print pascal_op_print_tab[] =
{
  {",", BINOP_COMMA, PREC_COMMA, 0},
  {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
  {"or", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},
  {"xor", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},
  {"and", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},
  {"=", BINOP_EQUAL, PREC_EQUAL, 0},
  {"<>", BINOP_NOTEQUAL, PREC_EQUAL, 0},
  {"<=", BINOP_LEQ, PREC_ORDER, 0},
  {">=", BINOP_GEQ, PREC_ORDER, 0},
  {">", BINOP_GTR, PREC_ORDER, 0},
  {"<", BINOP_LESS, PREC_ORDER, 0},
  {"shr", BINOP_RSH, PREC_SHIFT, 0},
  {"shl", BINOP_LSH, PREC_SHIFT, 0},
  {"+", BINOP_ADD, PREC_ADD, 0},
  {"-", BINOP_SUB, PREC_ADD, 0},
  {"*", BINOP_MUL, PREC_MUL, 0},
  {"/", BINOP_DIV, PREC_MUL, 0},
  {"div", BINOP_INTDIV, PREC_MUL, 0},
  {"mod", BINOP_REM, PREC_MUL, 0},
  {"@", BINOP_REPEAT, PREC_REPEAT, 0},
  {"-", UNOP_NEG, PREC_PREFIX, 0},
  {"not", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
  {"^", UNOP_IND, PREC_SUFFIX, 1},
  {"@", UNOP_ADDR, PREC_PREFIX, 0},
  {"sizeof", UNOP_SIZEOF, PREC_PREFIX, 0},
  {NULL, 0, 0, 0}
};

enum pascal_primitive_types {
#ifdef DELPHI_PRIMITIVE_TYPES
  /* EMBARCADERO LOCAL begin Delphi types */
  pascal_primitive_type_shortint,
  pascal_primitive_type_byte,
  pascal_primitive_type_boolean,
  pascal_primitive_type_smallint,
  pascal_primitive_type_word,
  pascal_primitive_type_nativeint,
  pascal_primitive_type_nativeuint,
  pascal_primitive_type_longint,
  pascal_primitive_type_integer,
  pascal_primitive_type_longword,
  pascal_primitive_type_cardinal,
  pascal_primitive_type_uint64,
  pascal_primitive_type_int64,
  pascal_primitive_type_single,
  pascal_primitive_type_double,
  pascal_primitive_type_real,
  pascal_primitive_type_extended,
  pascal_primitive_type_void,
  pascal_primitive_type_pointer,
  pascal_primitive_type_char,
  pascal_primitive_type_pchar,
  pascal_primitive_type_string,
  /* EMBARCADERO LOCAL end Delphi types */
#else // DELPHI_PRIMITIVE_TYPES
  pascal_primitive_type_int,
  pascal_primitive_type_long,
  pascal_primitive_type_short,
  pascal_primitive_type_char,
  pascal_primitive_type_float,
  pascal_primitive_type_double,
  pascal_primitive_type_void,
  pascal_primitive_type_long_long,
  pascal_primitive_type_signed_char,
  pascal_primitive_type_unsigned_char,
  pascal_primitive_type_unsigned_short,
  pascal_primitive_type_unsigned_int,
  pascal_primitive_type_unsigned_long,
  pascal_primitive_type_unsigned_long_long,
  pascal_primitive_type_long_double,
  pascal_primitive_type_complex,
  pascal_primitive_type_double_complex,
#endif // DELPHI_PRIMITIVE_TYPES
  nr_pascal_primitive_types
};

static void
pascal_language_arch_info (struct gdbarch *gdbarch,
			   struct language_arch_info *lai)
{
  const struct builtin_type *builtin = builtin_type (gdbarch);

#ifdef DELPHI_PRIMITIVE_TYPES
  lai->primitive_type_vector
    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_pascal_primitive_types + 1,
                              struct type *);
  /* EMBARCADERO LOCAL begin Delphi types */
  lai->primitive_type_vector [pascal_primitive_type_shortint]
    = init_type (TYPE_CODE_INT, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                 0, "shortint", (struct objfile *) NULL);
  lai->primitive_type_vector [pascal_primitive_type_byte]
    = init_type (TYPE_CODE_INT, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
	         TYPE_FLAG_UNSIGNED,
	         "byte", (struct objfile *) NULL);

  lai->bool_type_symbol = "boolean";
  lai->bool_type_default
    = lai->primitive_type_vector [pascal_primitive_type_boolean]
    = arch_type (gdbarch, TYPE_CODE_BOOL, 1, "boolean");

  lai->primitive_type_vector [pascal_primitive_type_smallint]
    = init_type (TYPE_CODE_INT, 16 / TARGET_CHAR_BIT,
	         0, "smallint", (struct objfile *) NULL);
  lai->primitive_type_vector [pascal_primitive_type_word]
    = init_type (TYPE_CODE_INT, 16 / TARGET_CHAR_BIT,
	         TYPE_FLAG_UNSIGNED,
                 "word", (struct objfile *) NULL);

  lai->primitive_type_vector [pascal_primitive_type_nativeint]
    = init_type (TYPE_CODE_INT, 32 / TARGET_CHAR_BIT,
	         0, "nativeint", (struct objfile *) NULL);
  lai->primitive_type_vector [pascal_primitive_type_nativeuint]
    = init_type (TYPE_CODE_INT, 32 / TARGET_CHAR_BIT,
	         TYPE_FLAG_UNSIGNED,
	         "nativeuint", (struct objfile *) NULL);

  lai->primitive_type_vector [pascal_primitive_type_longint]
    = init_type (TYPE_CODE_INT, 32 / TARGET_CHAR_BIT,
	         0, "longint", (struct objfile *) NULL);
  lai->primitive_type_vector [pascal_primitive_type_integer]
    = init_type (TYPE_CODE_INT, 32 / TARGET_CHAR_BIT,
	         0, "integer", (struct objfile *) NULL);
  lai->primitive_type_vector [pascal_primitive_type_longword]
    = init_type (TYPE_CODE_INT, 32 / TARGET_CHAR_BIT,
	         TYPE_FLAG_UNSIGNED,
                 "longword", (struct objfile *) NULL);
  lai->primitive_type_vector [pascal_primitive_type_cardinal]
    = init_type (TYPE_CODE_INT, 32 / TARGET_CHAR_BIT,
	         TYPE_FLAG_UNSIGNED,
                 "cardinal", (struct objfile *) NULL);

  lai->primitive_type_vector [pascal_primitive_type_uint64]
    = init_type (TYPE_CODE_INT, 64 / TARGET_CHAR_BIT,
	         0, "uint64", (struct objfile *) NULL);
  lai->primitive_type_vector [pascal_primitive_type_int64]
    = init_type (TYPE_CODE_INT, 64 / TARGET_CHAR_BIT,
	         TYPE_FLAG_UNSIGNED,
                 "int64", (struct objfile *) NULL);

  lai->primitive_type_vector [pascal_primitive_type_single]
    = arch_float_type (gdbarch, gdbarch_float_bit (gdbarch),
		       "single", gdbarch_float_format (gdbarch));
  lai->primitive_type_vector [pascal_primitive_type_double]
    = arch_float_type (gdbarch, gdbarch_double_bit (gdbarch),
		       "double", gdbarch_double_format (gdbarch));
  lai->primitive_type_vector [pascal_primitive_type_real]
    = arch_float_type (gdbarch, gdbarch_double_bit (gdbarch),
		       "real", gdbarch_double_format (gdbarch));
  lai->primitive_type_vector [pascal_primitive_type_extended]
    = arch_float_type (gdbarch, gdbarch_long_double_bit (gdbarch),
		       "extended", gdbarch_long_double_format (gdbarch));

  lai->primitive_type_vector [pascal_primitive_type_void]
    = builtin->builtin_void;
  lai->primitive_type_vector [pascal_primitive_type_pointer]
    = lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void",
                                      (struct objfile *) NULL));
  TYPE_NAME (lai->primitive_type_vector [pascal_primitive_type_pointer])
    = "pointer";

  /* FIXME: There's no easy way to set the lower bound in the LAI vector as in
       lai->string_lower_bound = pascal_string_lower_bound (current_gdbarch);
     because language functions want to test pointers to see if set.  
     We can't bash the string_lower_bound of the current language either,
     because it is const.  
     The best we can do is assert if things aren't what we expect.  */
  gdb_assert (current_language->string_lower_bound
	      == pascal_string_lower_bound (gdbarch));
  gdb_assert (current_language->la_language == language_pascal);

  /* Note: "char" will map to wchar_t or char16_t depending on target arch,
     but it will always be unsigned short.  */
  lai->string_char_type
    = lai->primitive_type_vector [pascal_primitive_type_char]
#if 0
    = init_type (TYPE_CODE_CHAR, 16 / TARGET_CHAR_BIT,
	         TYPE_FLAG_UNSIGNED,
	         "char", (struct objfile *) NULL);
#else
    = pascal_char_type (gdbarch);
#endif
  lai->primitive_type_vector [pascal_primitive_type_pchar]
    = lookup_pointer_type (lai->string_char_type);
  TYPE_NAME (lai->primitive_type_vector [pascal_primitive_type_pchar])
    = "pchar";

  lai->primitive_type_vector [pascal_primitive_type_string]
    = pascal_create_string_type (gdbarch);
  /* EMBARCADERO LOCAL end Delphi types */
#else // DELPHI_PRIMITIVE_TYPES
  lai->string_char_type = pascal_char_type (gdbarch);
  lai->primitive_type_vector
    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_pascal_primitive_types + 1,
                              struct type *);
  lai->primitive_type_vector [pascal_primitive_type_int]
    = builtin->builtin_int;
  lai->primitive_type_vector [pascal_primitive_type_long]
    = builtin->builtin_long;
  lai->primitive_type_vector [pascal_primitive_type_short]
    = builtin->builtin_short;
  lai->primitive_type_vector [pascal_primitive_type_char]
    = builtin->builtin_char;
  lai->primitive_type_vector [pascal_primitive_type_float]
    = builtin->builtin_float;
  lai->primitive_type_vector [pascal_primitive_type_double]
    = builtin->builtin_double;
  lai->primitive_type_vector [pascal_primitive_type_void]
    = builtin->builtin_void;
  lai->primitive_type_vector [pascal_primitive_type_long_long]
    = builtin->builtin_long_long;
  lai->primitive_type_vector [pascal_primitive_type_signed_char]
    = builtin->builtin_signed_char;
  lai->primitive_type_vector [pascal_primitive_type_unsigned_char]
    = builtin->builtin_unsigned_char;
  lai->primitive_type_vector [pascal_primitive_type_unsigned_short]
    = builtin->builtin_unsigned_short;
  lai->primitive_type_vector [pascal_primitive_type_unsigned_int]
    = builtin->builtin_unsigned_int;
  lai->primitive_type_vector [pascal_primitive_type_unsigned_long]
    = builtin->builtin_unsigned_long;
  lai->primitive_type_vector [pascal_primitive_type_unsigned_long_long]
    = builtin->builtin_unsigned_long_long;
  lai->primitive_type_vector [pascal_primitive_type_long_double]
    = builtin->builtin_long_double;
  lai->primitive_type_vector [pascal_primitive_type_complex]
    = builtin->builtin_complex;
  lai->primitive_type_vector [pascal_primitive_type_double_complex]
    = builtin->builtin_double_complex;

  lai->bool_type_symbol = "boolean";
  lai->bool_type_default = builtin->builtin_bool;
#endif // DELPHI_PRIMITIVE_TYPES
}

/* The target ABI may pass or return some structs by reference 
   TODO: Add check for additional types may be passed as reference 
   or returned via pointer written by function at struct_addr. */
static int
pascal_pass_by_reference (struct type *type)
{
  if (type != NULL 
      && (TYPE_CODE(type) == TYPE_CODE_STRUCT
	  || TYPE_CODE(type) == TYPE_CODE_UNION
	  || (TYPE_CODE(type) == TYPE_CODE_PTR
		&& TYPE_TARGET_TYPE (type) != NULL
		&& TYPE_DELPHI_CLASS (TYPE_TARGET_TYPE (type)))
	  || TYPE_CODE(type) == TYPE_CODE_STRING))
    return 1;  
  else
    return 0;
}

const struct language_defn pascal_language_defn =
{
  "pascal",			/* Language name */
  language_pascal,
  range_check_on,
  type_check_on,
  /* EMBARCADERO Local: set default for case sensitivity to off */
  case_sensitive_off,
  array_row_major,
  macro_expansion_no,
  &exp_descriptor_standard,
  pascal_parse,
  pascal_error,
  null_post_parser,
  pascal_printchar,		/* Print a character constant */
  pascal_printstr,		/* Function to print string constant */
  pascal_emit_char,		/* Print a single char */
  pascal_print_type,		/* Print a type using appropriate syntax */
  pascal_print_typedef,		/* Print a typedef using appropriate syntax */
  pascal_val_print,		/* Print a value using appropriate syntax */
  pascal_value_print,		/* Print a top-level value */
  NULL,				/* Language specific skip_trampoline */
  /* EMBARCADERO Local: self member access. */
  "self",		        /* name_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  NULL,				/* Language specific symbol demangler */
  NULL,				/* Language specific class_name_from_physname */
  pascal_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  /* EMBARCADERO LOCAL Delphi strings */
  /* FIXME: actual lower bound varies based on target.
     Dcc "nextgen" compilers use lower bound of 0, others use 1.  */
  0,				/* String lower bound */
  default_word_break_characters,
  default_make_symbol_completion_list,
  pascal_language_arch_info,
  default_print_array_index,
  pascal_pass_by_reference,
  pascal_get_string,
  LANG_MAGIC
};

void
_initialize_pascal_language (void)
{
  add_language (&pascal_language_defn);
}
